% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}

% allows for temporary adjustment of side margins
\usepackage{chngpage}

% just makes the table prettier (see \toprule, \bottomrule, etc. commands below)
\usepackage{booktabs}

\usepackage[utf8]{inputenc}

% URL handling
\usepackage{url}
\urlstyle{same}

% Todos
%\usepackage[colorinlistoftodos]{todonotes}
%\newcommand{\ke}[1]{\todo[size=\small, color=orange!40]{\textbf{Kai:} #1}}
%\newcommand{\tb}[1]{\todo[size=\small, color=green!40]{\textbf{Thomas:} #1}}


%\usepackage{makeidx}  % allows for indexgeneration

%\usepackage{amsmath}
\usepackage{amsmath, amssymb}
\usepackage{mathabx}

% monospace within text
\newcommand{\ms}[1]{\texttt{#1}}

% examples
\usepackage{fancyvrb}
\DefineVerbatimEnvironment{ex}{Verbatim}{numbers=left,numbersep=2mm,frame=single,fontsize=\scriptsize}

\usepackage{xspace}
% Einfache und doppelte Anfuehrungszeichen
\newcommand{\qs}{``} 
\newcommand{\qe}{''\xspace} 
\newcommand{\sqs}{`} 
\newcommand{\sqe}{'\xspace} 

% checkmark
\usepackage{tikz}
\def\checkmark{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;} 

% Xs
\usepackage{pifont}

% Tabellenabstände kleiner
\setlength{\intextsep}{10pt} % Vertical space above & below [h] floats
\setlength{\textfloatsep}{10pt} % Vertical space below (above) [t] ([b]) floats
% \setlength{\abovecaptionskip}{0pt}
% \setlength{\belowcaptionskip}{0pt}

\usepackage{tabularx}
\newcommand{\hr}{\hline\noalign{\smallskip}} % für die horizontalen linien in tabellen

% Todos
\usepackage[colorinlistoftodos]{todonotes}
\newcommand{\ke}[1]{\todo[size=\small, color=orange!40]{\textbf{Kai:} #1}}
\newcommand{\tb}[1]{\todo[size=\small, color=green!40]{\textbf{Thomas:} #1}}
\newcommand{\er}[1]{\todo[size=\small, color=red!40]{\textbf{Erman:} #1}}
\newcommand{\an}[1]{\todo[size=\small, color=red!40]{\textbf{Andy:} #1}}

\newenvironment{table-1cols}{
  \scriptsize
  \sffamily
  \vspace{0.3cm}
  \begin{tabular}{l}
  \hline
  \textbf{Requirements} \\
  \hline

}{
  \hline
  \end{tabular}
  \linebreak
}

\newenvironment{table-2cols}{
  \scriptsize
  \sffamily
  \vspace{0.3cm}
  \begin{tabular}{l|l}
  \hline
  \textbf{Requirements} & \textbf{Covering DSCLs} \\
  \hline

}{
  \hline
  \end{tabular}
  \linebreak
}

\newenvironment{complexity}{
  \scriptsize
  \sffamily
  \vspace{0.3cm}
  \begin{tabular}{l|l}
  \hline
  \textbf{Validation Type} & \textbf{Complexity} \\
  \hline

}{
  \hline
  \end{tabular}
  \linebreak
}

\newenvironment{DL}{
  \scriptsize
  \sffamily
  \vspace{0.3cm}
  \begin{tabular}{l}

}{
  \end{tabular}
  \linebreak
}

\newenvironment{evaluation}{
  \scriptsize
  \sffamily
  \vspace{0.3cm}
  \begin{tabular}{l|c|c|c|c|c|c}
  \hline
  \textbf{constraint} & \textbf{DSP} & \textbf{OWL2-DL} & \textbf{OWL2-QL} & \textbf{ReSh} & \textbf{ShEx} & \textbf{SPIN} \\
  \hline

}{
  \hline
  \end{tabular}
  \linebreak
}

\setcounter{secnumdepth}{5}

\begin{document}

%
%
\title{Expressivity and Effects on Complexity of RDF Constraint Languages}
%
\titlerunning{XXXXX}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{XXXXX\inst{1} \and XXXXX\inst{2}}
%
\authorrunning{XXXXX} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\institute{XXXXX\\
\email{XXXXX},\\ 
\and
XXXXX \\
\email{XXXXX} 
}

\maketitle              % typeset the title of the contribution

\begin{abstract}


\keywords{..}
\end{abstract}
%

\section{Motivation}

For many RDF applications, the formulation of constraints and the automatic validation of data according to these constraints is a much sought-after feature. 
In 2013, the W3C invited experts from industry, government, and academia to the RDF Validation Workshop\footnote{\url{http://www.w3.org/2012/12/rdf-val/}}, 
where first use cases have been presented and discussed. 
Two WGs, that follow up on this workshop and address RDF constraint formulation and validation, are established in 2014: 
the W3C RDF Data Shapes WG\footnote{\url{http://www.w3.org/2014/rds/charter}} and the DCMI RDF Application Profiles WG\footnote{\url{http://wiki.dublincore.org/index.php/RDF-Application-Profiles}}. 

\tb{ToDo for Thomas: RDF validation requirements database}

There are long and controversial discussions in these WGs if or if not OWL should be used RDF validation when assuming closed world semantics.
OWL is an instantiation of a DSCL which is high-level, human-friendly (human-readable and human-understandable), fairly concise, and very expressive.
There are lots of benefits but also a huge amount of drawbacks when using OWL for the purpose to formulate and to validate RDF constraints.

\begin{itemize}
	\item explain why specific OWL 2 constructs could be used for RDF validation 
	\item explain why specific OWL 2 constructs should not be used for RDF validation
\end{itemize}

For RDF, SPARQL is generally seen as the method of choice to validate data according to certain constraints, although it is not ideal for their formulation. 
In contrast, OWL 2 DL constraints are comparatively easy to understand, but lack an implementation to validate RDF data. \an{IMHO this should be decribed more precisely because validation in terms of inconsistency detection is still available, not sure about the completeness for OWL 2 DL}
Within our developed SPIN\footnote{\url{http://spinrdf.org/}} validation environment, we fully implemented an automatic validation of all OWL 2 DL constructs. \an{you should mention at this point that this validation is in terms of RDF validation, because inconsistency can't be done completely}
The implementation can be tested at \url{http://purl.org/net/rdfval-demo} and
the OWL 2 SPIN mapping is maintained at \url{https://github.com/boschthomas/OWL2-SPIN-Mapping}.

\tb{ToDo Thomas: constraint languages}

\textbf{Constraint Validation with Reasoning}

Constraint validation does not appear to be part of the services provided by
OWL.  This has lead to claims that OWL cannot be used for constraint
validation.  However reasoning, which is the core service provided by OWL,
and constraint validation are indeed very closely related.

\an{a more formal example would be nice! ;)}
Reasoning is the process of determining what follows from what has been
stated.  Reasoning ranges from simple (students are people, John is a
student, therefore John is a person) to the very complex. Reasoning can
also recognize impossibilities (students are people, John is a student, John
is not a person, therefore there is a contradiction). 

\begin{itemize}
	\item inferencing as a pre validation step
	\item both should be possible: (1) constraint validation with reasoning and (2) constraint validation without reasoning \an{we should mention a reason why we need this...}
\end{itemize}

With regard to typing, W3C is assuming (AFAIK) that all types will be
explicit in the instance data - for the purposes of validation. There is
nothing, however, to prevent an application from running reasoning prior
to validation to add inferred triples to the data being validated. But
the general feeling right now is that validation acts on instance data
without requiring that the validator apply reasoning in order to do so.

%Nehmen wir nun an, dass dein Framework welches entsprechende SPARQL Queries generiert diese auf einem SPARQL Endpoint evaluiert der zu der vorliegenden Ontologie bzw. des darin verwendeten OWL 2 Profils das entsprechende Entailment Regime realisiert, wären die zurückgegebenen Resultsets vollständig. Wie das Entailment Regime im Endpoint realisiert ist, also durch Query Rewriting oder durch Vervollständigung der ABox, ist dabei irrelevant.
%
%Wie allerdings bspw. in 
%\url{https://www.uni-ulm.de/fileadmin/website_uni_ulm/iui.inst.090/Lehre/WS_2011-2012/SemWebGrundlagen/LectureNotes.pdf}
%auf Seite 51 veranschaulicht, ist die Komplexität des Reasoning abhängig von der zugrunde gelegten Sprache und kann daher nur in bestimmten Fällen effizient durchgeführt werden. Wie in unserem letzten Paper beschrieben zielt unter anderem die Definition von DL-Lite gerade darauf ab Reasoning Aufgaben und Query Answering effizient zu ermöglichen und ist Grundlage des OWL 2 QL Profils. Nun ist allgemein bekannt, dass die logische Konsistenz für diese Art von Sprachen effizient geprüft werden kann. 
%
%Allerding wäre wie bspw. in 
%\url{http://www.aifb.kit.edu/images/d/d2/2005_925_Haase_Consistent_Evol_1.pdf} beschrieben auch eine sogenannte 'User-defined Consistency' denkbar. Genau an dieser Stelle könnten wir ansetzen.

We answer the following \textbf{research questions}:
\begin{enumerate}
	\item which constraints are expressible by DL?
	\item which constraints are not expressible by DL but by a query language such as Datalog or SPARQL?
	\item for which requirements formulating RDF constraints the expressivity of DL-Lite$_A$ respectively OWL 2 QL is sufficient?
	\item for which requirements additional constraint languages are needed to express related constraints?
	\item which constraint languages are suitable to express these constraints?
	\item what are the effects on complexity to express these constraints with and without OWL 2 QL and OWL 2 DL inferencing?
	\item what are the effects on complexity of constraints expressible by DL?
	\item what are the effects on complexity of constraints not expressible by DL but by a query language?
\end{enumerate}

\textbf{Contributions} of this paper are:
\begin{enumerate}
  \item
	\item
	\item We evaluated to which extend the five possible standard constraint languages fulfill each requirement.
\end{enumerate}

\textbf{Ideas}

\begin{itemize}
	\item RDF validation using OWL 2 QL reasoning by SPARQL query expansion
	\item if using OWL 2 DL as constraint language or using constraints equivalent to OWL 2 QL you can use reasoning 
	\item reasoning can also be executed using SPARQL query expansion.
	\item reasoning not executing using reasoner
\end{itemize}

\begin{itemize}
	\item complete with reasoning | OW
	\item complete without reasoning | CW
	\item there is no query rewriting mechanism for OWL 2, just for OWL 2 QL
	\item show that OWL 2 QL and further constraint languages together are complete
\end{itemize}

\section{RDF Validation Requirements and Reasoning}

I would explain the addressed problem by an example, like the following:\\
consider the KB $\mathcal{K} = \{Person \sqsubseteq \exists hasAncestor.Person, Person(\textbf{Thomas})\}$, using the OWA we know that \textbf{Thomas} has some Ancestor, but we do not know them, so $\mathcal{K}$ is consistent. In CWA the constraint needs to be satisfied only by named individuals, so there are some validation errors.\\
A more complex example could be: \\
Assume $\mathcal{K} = \{Person \sqsubseteq \exists hasAncestor.Person, (\textsf{funct } hasAncestor), Person(\textbf{Thomas}), hasAncestor(\textbf{Thomas}, \textbf{Erman}), hasAncestor(\textbf{Thomas}, \textbf{Andy})\}$, in CWA there is a clash because of the functional role \textit{hasAncestor} and the UNA, but in OWA there is no UNA by default so the reasoner will produce that $\textbf{Erman} \equiv \textbf{Andy}$. But this is not a problem if we add UNA to the OWA, like in the \textit{DL-Lite} family.
Another point would be that if we perform RDF validation with no reasoning, we will get a further clash \textbf{Erman} is not defined to be a \textit{Person}, but if we do the validation after some reasoning, there will be no clash, because by definition the following definition will be inferred: $Person(\textbf{Erman})$. So in my understanding it would be more useful/reasonable to perform the validation task after reasoning.

\tb{ToDO Thomas: RDF Validation Requirements and Inferencing}

\subsection{OWL 2 QL Reasoning}

\tb{ToDo for Andy and Erman: may you shorten the next 3 paragraphs? What is needed for the paper?}

OWL 2 profiles (or fragments in logic literature) are restricted (sublanguage) versions of OWL 2 that offers different trade-offs regarding expressivity  vs. efficiency in reasoning. There are three main  profiles of OWL 2, which are OWL 2 QL, OWL 2 RL and OWL 2 EL namely, each designed to  be useful for different purposes and application scenarios. The choice of which profile to use is purpose-specific on what to express and to perform the reasoning about. We refer reader to \cite{owl2profiles2008} for a comprehensive treatment of those profiles. 

OWL 2 QL is an OWL 2 profile which focuses on reasoning on query answering with very large size of instance data. The acronym QL stands for query language as query answering in this profile can be done by rewriting queries into a standard relational query language (also known as First-Order Rewritability). Also, conjunctive query answering can be done by using conventional relational database systems. Aiming at efficiency on working with large size data, the expressive power of the profile is quite limited as expected. As a result of this, reasoning in OWL 2 QL is highly efficient so that sound and complete conjunctive query answering can be performed in \textsc{LogSpace} in the size of the data assertions as well as  the ontology consistency and class expression subsumption can be performed in polynomial time.

OWL 2 QL is based on the DL-Lite family of description logics, a tractable family of fragments of first-order logic \cite{Artale2009,Calvanese2007}. 
However, an important difference between the DL-Lite family and OWL is the
unique name assumption (UNA). UNA is common in data management, therefore it is adopted in the DL-Lite family whereas not adopted in OWL. In OWL, one uses constructs \textbf{sameAs} or \textbf{differentFrom} explicitly to state that two individuals, say  $a$ and $b$, are the \emph{same} or {different} respectively. For that reason in OWL 2 QL, any construct e.g., number restrictions or functionality constraints which can interfere with UNA and also which can cause higher complexity without the UNA, has been avoided.


Among the members of DL-Lite family, DL-Lite$_R$ is the one that OWL 2 QL is based on. The reason is to avoid any problematic issue which might appear in the explicit axiomatization of UNA, since  DL-Lite$_R$ in general does not require the UNA, because making this assumption has no semantic affect on a DL-Lite$_R$ ontology. 

\textbf{Subsumption.}
Subsumption relationships of both classes and properties are part of basic reasoning.

\begin{DL}
:Jedi $\sqsubseteq$ :FeelingForce \\
:JediMaster $\sqsubseteq$ :Jedi \\
\end{DL}

All Jedi masters are Jedis feeling the force.
These sub-class relationships can also be expressed by OWL 2 QL:

\begin{ex}
:Jedi rdfs:subClassOf :FeelingForce . 
:JediMaster rdfs:subClassOf :Jedi . 
\end{ex}

Valid data must contain the three class assignments:

\begin{ex}
:Yoda a :JediMaster . 
:Yoda a :Jedi . 
:Yoda a :FeelingForce .
\end{ex}

These class assignments can be either explicitly stated or implicitly inferred when reasoning is performed before actually validating the data.

When only the triple \ms{:Yoda a :JediMaster} is given and reasoning is not executed, then a constraint violation is raised.
After reasoning, however, the triples \ms{:Yoda a :Jedi , :FeelingForce} are inferred resulting in valid data. 

\textbf{Property Domain.}
The property domain constraint

\begin{DL}
$\exists$ :studentOf . $\top$ $\sqsubseteq$ :JediStudent \\
\end{DL}

restricts that individuals having :studentOf relationships must be Jedi students.
This property domain constraint can also be expressed by OWL 2 QL:

\begin{ex}
:studentOf rdfs:domain :JediStudent .
\end{ex}

Without reasoning, the data \ms{:Anakin :studentOf :Obi-Wan} is invalid and causes a constraint violation, as it is not explicitly stated that \ms{:Anakin} is assigned to the class \ms{:Jedi}. 
When inferencing is performed before validating, the class assignment \ms{:Anakin rdf:type :Jedi} is inferred which prevents the constraint violation to be raised.

\subsection{OWL 2 DL Reasoning}

%\tb{ToDO for Erman and Andy: can you please write a short paragraph about OWL 2 DL reasoning?}

The Semantic Web ontology language OWL 2 DL \footnote{See \url{http://www.w3.org/TR/owl2-direct-semantics/}.} was standardized by
the World Wide Web Consortium (W3C) in 2009 (and updated in 2012) as a
description logic-like formalism.  OWL 2 DL has high expressivity, yet maintains  decidability for main reasoning tasks e.g., ontology satisability, 
entailment checking. The drawback of its expressive power results as a lack of computational efficiency in performance. In general, reasoning in OWL 2 DL is in \textsc{N2exptime} \cite{owl2profiles2008}. 

As a result of its expressive power, OWL 2 DL allows a large variety of sophisticated modeling capabilities for many application domains.  On the other hand, to maintain the decidability, OWL 2 DL has a numerous ways of syntactic restrictions. One example is that OWL 2 DL allows  expressing transitive properties as well as asymmetric properties, yet a property to be both transitive and asymmetric (just as ancestor relation) is not allowed. In the sequel, from RDF validation perspective, we will give some examples of constraints that remains at the outside of its scope. 



\textbf{Existential Quantification.}

\begin{DL}
$\exists$ :hasLaserSword . :LaserSword
\end{DL}

This existential quantification contains all those individuals that are connected by :hasLaserSword to an individual that is an instance of the class :LaserSword.
In OWL 2 DL, this existential quantification can also be expressed:

\begin{ex}
[ a owl:Restriction ;
  owl:onProperty :hasLaserSword ;
  owl:someValuesFrom :LaserSword ;
  rdfs:subClassOf :Jedi ] .
\end{ex}

When our data contains the triple \ms{:Luke :hasLaserSword :BlueLaserSword} and we perform reasoning, we can infer that \ms{:Luke} is a :Jedi, as he has a laser sword.
As the individual \ms{:Luke} is assigned to the class :Jedi, all constraint associated with this class are also validated, for example that Jedis must have blue laser swords.
Without reasoning, these constraints won't be validated as \ms{:Luke} is not within the class extension of \ms{:Jedi}.

\section{RDF Validation Requirements}

For the majority of the requirements to formulate RDF constraints reasoning is not related to the constraints and is therefore not performed prior to the validation.

\subsection{Expressible by OWL 2 QL}

\textbf{Literal Pattern Matching.}
There are multiple use cases associated with the requirement to match literals according to given patterns\footnote{corresponds to R-44-PATTERN-MATCHING-ON-RDF-LITERALS}.
A social security number, for example, is a string that matches a given regular expression - which can be expressed by OWL 2 QL: 

\begin{ex}
SSN 
    a rdfs:Datatype ;
    owl:equivalentClass [
        a rdfs:Datatype ;
        owl:onDatatype xsd:string ;
        owl:withRestrictions ( 
            [ xsd:pattern "[0-9]{3}-[0-9]{2}-[0-9]{4}" ] ) ] .
hasSSN rdfs:range SSN .
\end{ex}

The second axiom defines \ms{SSN} as an abbreviation for a datatype restriction on \ms{xsd:string}. 
The first axiom explicitly declares \ms{SSN} to be a datatype. 
The datatype \ms{SSN} can be used just like any other datatype like in the third axiom to define the range of the \ms{hasSSN} property.
The literal pattern matching constraint above validates \ms{hasSSN} literals according to the stated regular expression causing a constraint violation for the triple 
\ms{TimBernersLee hasSSN "123456789"\textasciicircum{}\textasciicircum{}SSN}, 
but not for the triple \ms{TimBernersLee hasSSN "123-45-6789"\textasciicircum{}\textasciicircum{}SSN}.

\subsection{Not Expressible by OWL 2 QL but by OWL 2 DL}

\textbf{Allowed Values}\footnote{corresponds to R-30-ALLOWED-VALUES-FOR-RDF-OBJECTS and R-37-ALLOWED-VALUES-FOR-RDF-LITERALS}\textbf{.}
It is a common requirement to narrow down the value space of a property by an exhaustive enumeration of the valid values (both literals or resources). This is often rendered in drop down boxes or radio buttons in user interfaces. 
The constraint 'Jedis can only have blue, green, or white laser swords' can be expressed by OWL 2 DL, DSP, ReSh, ShEx, SPIN, and SPARQL.

\begin{DL}
Jedi $\equiv$ $\exists$ laserSwordColor . \{blue, green, white\} \\
\end{DL}

In DSP, the constraint does not look that concise:

\begin{ex}
personDescriptionTemplate
    a dsp:DescriptionTemplate ;
    dsp:resourceClass Jedi ;
    dsp:statementTemplate [
        a dsp:LiteralStatementTemplate ;
        dsp:property laserSwordColor ;
        dsp:literalConstraint [
            a dsp:LiteralConstraint ;
            dsp:literal "blue" ;
            dsp:literal "green" ;
            dsp:literal "white"] ] .
\end{ex}

When representing the constraint by OWL2 DL a new datatype is defined by simply enumerating its literals:

\begin{ex}
laserSwordColor rdfs:range laserSwordColors . 
laserSwordColors
    a rdfs:Datatype .
    owl:oneOf ( "blue" "green" "white" ) .
\end{ex}

ReSh can also be used for this purpose:

\begin{ex}
Jedi a rs:ResourceShape ;
    rs:property [
        rs:name "laserSwordColor" ;
        rs:propertyDefinition laserSwordColor ;
        rs:allowedValue "blue" , "green" , "white" ;
        rs:occurs rs:Exactly-one ;
    ] .
\end{ex}

ShEx is the most intuitive and concise means representing the allowed values constraint:

\begin{ex}
Jedi {
    laserSwordColor ('blue' 'green' 'white') }
\end{ex}

Data containing the triples \ms{Yoda a Jedi ; laserSwordColor 'blue'} is valid, 
whereas data including the triples \ms{DarthMaul a Jedi ; laserSwordColor 'red'} is invalid.

\textbf{Context-Specific Exclusive OR of Properties}\footnote{corresponds to  R-11-CONTEXT-SPECIFIC-EXCLUSIVE-OR-OF-PROPERTIES}\textbf{.}
An individual can either have a relationship via property A or via property B, but not both.
To take an example, a Jedi is either attacking by sword or by force but not both (such a fight would not be fair):

\begin{DL}
:Jedi $\sqsubseteq$ ($\neg$ A $\sqcap$ B) $\sqcup$ (A $\sqcap$ $\neg$ B) \\
A $\equiv$ $\forall$ :attackingBySword . xsd:boolean \\
B $\equiv$ $\forall$ :attackingByForce . xsd:boolean \\ 
\end{DL}

Context-specific exclusive OR of properties can be expressed by ShEx. 
In this case, the constraint context is the class \ms{:Jedi}.

\begin{ex}
:Jedi { (  
    :attackingBySword xsd:boolean | 
    :attackingByForce xsd:boolean ) }
\end{ex}

The same constraint may be expressed by OWL 2 DL, but not very intuitively and concisely.
This can rather be seen as a workaround, as anonymous classes are built for each of the exclusive properties.

\begin{ex}
:Jedi owl:disjointUnionOf ( :CC1 :CC2 ) . 
:CC1 rdfs:subClassOf [
    a owl:Restriction ;
    owl:onProperty :attackingBySword ;
    owl:allValuesFrom xsd:boolean ] .
:CC2 rdfs:subClassOf [
    a owl:Restriction ;
    owl:onProperty :attackingByForce ;
    owl:allValuesFrom xsd:boolean ] .
\end{ex}

Considering the following data, Luke as well as Darth Sidious are associated with the class \ms{:Jedi}.
As Darth Sidious has both relationships, a constraint Violation is raised.

\begin{ex}
:Luke
    a :Jedi ; 
    :attackingBySword true .
:DarthSidious
    a :Jedi ; 
    :attackingByForce true ;
    :attackingBySword true ;
\end{ex}

\subsection{Not Expressible by OWL 2 DL But by Other Constraint Languages}

The majority of constraints can neither be expressed by OWL 2 QL nor by OWL 2 DL. 
In such cases, these constraints are represented by other constraint languages like DSP, ShEx, ReSh, or SPIN.

\textbf{Default Values.}
It should be possible to declare the default value for a given object and data property, e.g. so that input forms can be pre-populated and to insert a required property that is missing in a web service call. 
Siths have per default two red laser swords.
If there is only stated that Darth Maul is a Sith (\ms{:DarthMaul a :Sith .}), then additional default triples should be inferred automatically: 

\begin{ex}
:DarthMaul 
    :laserSwordColor "red"^^xsd:string ;
    :numberLaserSwords "2"^^xsd:nonNegativeInteger .
\end{ex}

The default values constraint can only be expressed by ReSh, SPIN, and SPARQL.
In SPIN, we can define a rule associated with the class \ms{owl:Thing}.
This rule is applicable for each resource, as each resource is implicitly of the type \ms{owl:Thing}. 

\begin{ex}
owl:Thing spin:rule [ a sp:Construct ; sp:text """
    CONSTRUCT {
        ?this :laserSwordColor "red"^^xsd:string ;
              :numberLaserSwords "2"^^xsd:nonNegativeInteger . }
    WHERE {             
        ?this a :Sith . } """ ; ] .
\end{ex}

For each resource, the SPARQL CONSTRUCT query within the rule is executed creating the default triples.
ReSh can also be used to express default values:

\begin{ex}
:Sith a rs:ResourceShape ;
    rs:property [
        rs:name "laserSwordColor" ;
        rs:propertyDefinition :laserSwordColor ;
        rs:valueType xsd:string ;
        rs:defaultValue "red"^^xsd:string
        rs:occurs rs:Exactly-one ; ] .
\end{ex}

\section{Evaluation}

We evaluated to which extend the five possible standard constraint languages fulfill each requirement to formulate RDF constraints.
Tilde means that this constraint may be fulfilled by that particular constraint language - either by limitations, workarounds, or extensions.
We also evaluated if a specific constraint is fulfilled by OWL 2 QL or if the more expressive OWL 2 DL is needed. 
Inferencing may be performed prior to validating constraints. This is marked with an asterisk. 

We divide these constraints into three classes:

\begin{itemize}
	\item constraints expressible by OWL 2 QL
	\item constraints not expressible by OWL 2 QL but by OWL 2 DL
	\item constraints only expressible by other DSCLs
\end{itemize}

Bosch et al. explained each requirement and associated constraint in detail and give at least one example for each of them\cite{BoschNolleAcarEckert2015}.
In order to logically underpin each requirement, we added mappings to DL.  

\tb{How should we publish this? ordering of author not determined so far}
 
\textbf{Constraints Expressible by OWL 2 QL.}

\begin{evaluation}
\textcolor{blue}{*Subsumption} & \ding{55} & $\checkmark$ & $\checkmark$ & $\sim$ & $\checkmark$ & $\checkmark$ \\
\textcolor{blue}{*Class Equivalence} & \ding{55} & $\checkmark$ & $\checkmark$ & \ding{55} & \ding{55} & $\checkmark$ \\
\textcolor{blue}{*Sub Properties} & \ding{55} & $\checkmark$ & $\checkmark$ & \ding{55} & \ding{55} & $\checkmark$ \\
\textcolor{blue}{*Property Domain} & \ding{55} & $\checkmark$ & $\checkmark$ & \ding{55} & \ding{55} & $\checkmark$ \\
\textcolor{blue}{*Property Range} & \ding{55} & $\checkmark$ & $\checkmark$ & \ding{55} & \ding{55} & $\checkmark$ \\
\textcolor{blue}{*Inverse Object Properties} & \ding{55} & $\checkmark$ & $\checkmark$ & $\sim$ & \ding{55} & $\checkmark$ \\
\textcolor{blue}{*Symmetric Object Properties} & \ding{55} & $\checkmark$ & $\checkmark$ & \ding{55} & \ding{55} & $\checkmark$ \\
\textcolor{blue}{*Asymmetric Object Properties} & \ding{55} & $\checkmark$ & $\checkmark$ & \ding{55} & \ding{55} & $\checkmark$ \\
\textcolor{blue}{*Reflexive Object Properties} & \ding{55} & $\checkmark$ & $\checkmark$ & \ding{55} & \ding{55} & $\checkmark$ \\
\textcolor{blue}{*Irreflexive Object Properties} & \ding{55} & $\checkmark$ & $\checkmark$ & \ding{55} & \ding{55} & $\checkmark$ \\
Disjoint Properties & \ding{55} & $\checkmark$ & $\checkmark$ & \ding{55} & \ding{55} & $\checkmark$ \\
Disjoint Classes & \ding{55} & $\checkmark$ & $\checkmark$ & \ding{55} & \ding{55} & $\checkmark$ \\
Context-Sp. Property Groups & \ding{55} & $\sim$ & $\sim$ & $\checkmark$ & $\checkmark$ & $\checkmark$ \\
Context-Sp. Inclusive OR of P. & \ding{55} & $\sim$ & $\sim$ & & \ding{55} & $\checkmark$ \\
Context-Sp. Inclusive OR of P. Groups & \ding{55} & $\sim$ & $\sim$ & & \ding{55} & $\checkmark$ \\
Recursive Queries & $\checkmark$ & $\checkmark$ & $\checkmark$ & $\checkmark$ & $\checkmark$ & $\sim$ \\
Individual Inequality & \ding{55} & $\checkmark$ & $\checkmark$ & \ding{55} & \ding{55} & $\checkmark$ \\
\textcolor{blue}{*Equivalent Properties} & \ding{55} & $\checkmark$ & $\checkmark$ & \ding{55} & \ding{55} & $\checkmark$ \\
Property Assertions & \ding{55} & $\checkmark$ & $\sim$ & \ding{55} & \ding{55} & $\checkmark$ \\
Data Property Facets & \ding{55} & $\checkmark$ & $\checkmark$ & \ding{55} & \ding{55} & $\checkmark$ \\
Literal Pattern Matching & \ding{55} & $\checkmark$ & $\checkmark$ & $\checkmark$ & $\checkmark$ & $\checkmark$ \\
Negative Literal Pattern Matching & \ding{55} & $\checkmark$ & $\checkmark$ & & & $\checkmark$ \\
\end{evaluation}

\textbf{Constraints not Expressible by OWL 2 QL but by OWL 2 DL.}

\begin{evaluation}
\textcolor{blue}{*Object Property Paths} & \ding{55} & $\checkmark$ & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
\textcolor{blue}{*Intersection} & \ding{55} & $\checkmark$ & \ding{55} & & & $\checkmark$ \\
\textcolor{blue}{*Disjunction} & \ding{55} & $\checkmark$ & \ding{55} & & & $\checkmark$ \\
\textcolor{blue}{*Negation} & \ding{55} & $\checkmark$ & \ding{55} & & & $\checkmark$ \\
\textcolor{blue}{*Existential Quantification} & \ding{55} & $\checkmark$ & \ding{55} & $\sim$ & $\sim$ & $\checkmark$ \\
\textcolor{blue}{*Universal Quantification} & \ding{55} & $\checkmark$ & \ding{55} & & & $\checkmark$ \\
\textcolor{blue}{*Minimum Unqualified Cardinality} & $\checkmark$ & $\checkmark$ & \ding{55} & $\sim$ & $\checkmark$ & $\checkmark$ \\
\textcolor{blue}{*Minimum Qualified Cardinality} & $\checkmark$ & $\checkmark$ & \ding{55} & $\sim$ & $\checkmark$ & $\checkmark$ \\
\textcolor{blue}{*Maximum Unqualified Cardinality} & $\checkmark$ & $\checkmark$ & \ding{55} & $\sim$ & $\checkmark$ & $\checkmark$ \\
\textcolor{blue}{*Maximum Qualified Cardinality} & $\checkmark$ & $\checkmark$ & \ding{55} & $\sim$ & $\checkmark$ & $\checkmark$ \\
\textcolor{blue}{*Exact Unqualified Cardinality} & $\checkmark$ & $\checkmark$ & \ding{55} & $\sim$ & $\checkmark$ & $\checkmark$ \\
\textcolor{blue}{*Exact Qualified Cardinality} & $\checkmark$ & $\checkmark$ & \ding{55} & $\sim$ & $\checkmark$ & $\checkmark$ \\
\textcolor{blue}{*Transitive Object Properties} & \ding{55} & $\checkmark$ & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
Context-Sp. Exclusive OR of P. & \ding{55} & $\checkmark$ & \ding{55} & & $\checkmark$ & $\checkmark$ \\
Context-Sp. Exclusive OR of P. Groups & \ding{55} & $\sim$ & \ding{55} & $\checkmark$ & $\checkmark$ & $\checkmark$ \\
Allowed Values & $\checkmark$ & $\checkmark$ & \ding{55} & $\checkmark$ & $\checkmark$& $\checkmark$ \\
Not Allowed Values & \ding{55} & $\checkmark$ & \ding{55} & \ding{55} & $\checkmark$ & $\checkmark$ \\
Literal Ranges & \ding{55} & $\checkmark$ & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
Negative Literal Ranges & \ding{55} & $\checkmark$ & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
Required Properties & $\checkmark$ & $\checkmark$ & \ding{55} & $\checkmark$ & $\checkmark$ & $\checkmark$ \\
Optional Properties & $\checkmark$ & $\checkmark$ & \ding{55} & $\checkmark$ & $\checkmark$ & $\checkmark$ \\
Repeatable Properties & $\checkmark$ & $\checkmark$ & \ding{55} & $\checkmark$ & $\checkmark$ & $\checkmark$ \\
Negative Property Constraints & \ding{55} & $\checkmark$ & \ding{55} & & $\checkmark$ & $\checkmark$ \\
\textcolor{blue}{*Individual Equality} & \ding{55} & $\checkmark$ & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
\textcolor{blue}{*Functional Properties} & \ding{55} & $\checkmark$ & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
\textcolor{blue}{*Inverse-Functional Properties} & \ding{55} & $\checkmark$ & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
\textcolor{blue}{*Value Restrictions} & & $\checkmark$ & \ding{55} & & & $\checkmark$ \\
\textcolor{blue}{*Self Restrictions} & \ding{55} & $\checkmark$ & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
Primary Key Properties & \ding{55} & $\checkmark$ & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
\end{evaluation}

\textbf{Constraints Only Expressible by Other DSCLs.}

\begin{evaluation}
\textcolor{blue}{*Class-Specific Property Range} & $\checkmark$ & \ding{55} & \ding{55} & $\checkmark$ & $\checkmark$ & $\checkmark$ \\
\textcolor{blue}{*Class-Sp. Reflexive Object P.} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
Membership in Controlled Vocabularies & $\checkmark$ & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
IRI Pattern Matching & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ & $\checkmark$ \\
Literal Value Comparison & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ & $\checkmark$ \\
Define Order & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
Validation Levels & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
String Operations & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
Context-Specific Valid Classes & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
Context-Specific Valid Properties & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
Default Values & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ & \ding{55} & $\checkmark$ \\
Mathematical Operations & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
Language Tag Matching & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
Language Tag Cardinality & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
Whitespace Handling & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
HTML Handling & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
Conditional Properties & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
Recommended Properties & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
Handle RDF Collections & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
Value is Valid for Datatype & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
\textcolor{blue}{*Exploiting Class/Property Specialization Ontology Axioms} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ \\
\textcolor{blue}{*Cardinality Shortcuts} & \ding{55} & \ding{55} & \ding{55} & $\checkmark$ & $\checkmark$ & $\checkmark$ \\
\end{evaluation}

\section{Computational Complexity of RDF Constraints}

According to our evaluation of requirements to formulate RDF constraints, we identified three main ways of validating constraints.

\begin{enumerate}
	\item validation by query answering without reasoning
	\item validation by query answering with OWL 2 QL reasoning
	\item validation by query answering with OWL 2 DL reasoning
\end{enumerate}

The next table gives an overview of the computational complexity for RDF validation when it is performed -with and without reasoning. 

\begin{complexity}
validation by query answering without reasoning & \textsc{Pspace}-Complete \\
validation by query answering with OWL 2 QL reasoning & \textsc{Ptime} \\
validation by query answering with OWL 2 DL reasoning & \textsc{N2exptime} \\
\end{complexity}


What is considered by rdf validation w/o reasoning, corresponds to performing SPARQL queries.  It is known that performing SPARQL queries is in \textsc{Pspace}-Complete \cite{Perez2009}. Since OWL 2 profiles are based on DL-Lite family and query answering in OWL 2 QL is in \textsc{LogSpace} (or rather in AC$^0$ ) \cite{Calvanese2007}, so is the constraint validation by queries with  reasoning. Furthermore, TBox reasoning in OWL 2 QL is in \textsc{Ptime} \cite{Calvanese2007}, hence complete query rewriting as well as combined complexity (reasoning and than querying) is in \textsc{Ptime} \cite{Artale2009,Calvanese2007}.  With the more expressive profile OWL 2 DL, reasoning is in \textsc{N2exptime} \cite{owl2profiles2008} which is a class of considerably higher complexity.


\section{Related Work}

\section{Conclusion and Future Work}

\bibliography{../../literature/literature}{}
\bibliographystyle{plain}
\setcounter{tocdepth}{1}
%\listoftodos
\end{document}
