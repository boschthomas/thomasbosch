% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}

% allows for temporary adjustment of side margins
\usepackage{chngpage}

% just makes the table prettier (see \toprule, \bottomrule, etc. commands below)
\usepackage{booktabs}

\usepackage[utf8]{inputenc}

% URL handling
\usepackage{url}
\urlstyle{same}

% Todos
%\usepackage[colorinlistoftodos]{todonotes}
%\newcommand{\ke}[1]{\todo[size=\small, color=orange!40]{\textbf{Kai:} #1}}
%\newcommand{\tb}[1]{\todo[size=\small, color=green!40]{\textbf{Thomas:} #1}}


%\usepackage{makeidx}  % allows for indexgeneration

%\usepackage{amsmath}
\usepackage{amsmath, amssymb}
\usepackage{mathabx}

% monospace within text
\newcommand{\ms}[1]{\texttt{#1}}

% examples
\usepackage{fancyvrb}
\DefineVerbatimEnvironment{ex}{Verbatim}{numbers=left,numbersep=2mm,frame=single,fontsize=\scriptsize}

\usepackage{xspace}
% Einfache und doppelte Anfuehrungszeichen
\newcommand{\qs}{``} 
\newcommand{\qe}{''\xspace} 
\newcommand{\sqs}{`} 
\newcommand{\sqe}{'\xspace} 

% checkmark
\usepackage{tikz}
\def\checkmark{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;} 

% Xs
\usepackage{pifont}

% Tabellenabstände kleiner
\setlength{\intextsep}{10pt} % Vertical space above & below [h] floats
\setlength{\textfloatsep}{10pt} % Vertical space below (above) [t] ([b]) floats
% \setlength{\abovecaptionskip}{0pt}
% \setlength{\belowcaptionskip}{0pt}

\usepackage{tabularx}
\newcommand{\hr}{\hline\noalign{\smallskip}} % für die horizontalen linien in tabellen

% Todos
\usepackage[colorinlistoftodos]{todonotes}
\newcommand{\ke}[1]{\todo[size=\small, color=orange!40]{\textbf{Kai:} #1}}
\newcommand{\tb}[1]{\todo[size=\small, color=green!40]{\textbf{Thomas:} #1}}

\newenvironment{table-1cols}{
  \scriptsize
  \sffamily
  \vspace{0.3cm}
  \begin{tabular}{l}
  \hline
  \textbf{Requirements} \\
  \hline

}{
  \hline
  \end{tabular}
  \linebreak
}

\newenvironment{table-2cols}{
  \scriptsize
  \sffamily
  \vspace{0.3cm}
  \begin{tabular}{l|l}
  \hline
  \textbf{Requirements} & \textbf{Covering DSCLs} \\
  \hline

}{
  \hline
  \end{tabular}
  \linebreak
}

\newenvironment{complexity}{
  \scriptsize
  \sffamily
  \vspace{0.3cm}
  \begin{tabular}{l|l}
  \hline
  \textbf{Validation Type} & \textbf{Complexity} \\
  \hline

}{
  \hline
  \end{tabular}
  \linebreak
}

\newenvironment{DL}{
  \scriptsize
  \sffamily
  \vspace{0.3cm}
  \begin{tabular}{l}

}{
  \end{tabular}
  \linebreak
}

\setcounter{secnumdepth}{5}

\begin{document}

%
%
\title{Expressivity and Effects on Complexity of RDF Constraint Languages}
%
\titlerunning{XXXXX}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{XXXXX\inst{1} \and XXXXX\inst{2}}
%
\authorrunning{XXXXX} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\institute{XXXXX\\
\email{XXXXX},\\ 
\and
XXXXX \\
\email{XXXXX} 
}

\maketitle              % typeset the title of the contribution

\begin{abstract}


\keywords{..}
\end{abstract}
%

\section{Motivation}

For many RDF applications, the formulation of constraints and the automatic validation of data according to these constraints is a much sought-after feature. 
In 2013, the W3C invited experts from industry, government, and academia to the RDF Validation Workshop\footnote{\url{http://www.w3.org/2012/12/rdf-val/}}, 
where first use cases have been presented and discussed. 
Two WGs, that follow up on this workshop and address RDF constraint formulation and validation, are established in 2014: 
the W3C RDF Data Shapes WG\footnote{\url{http://www.w3.org/2014/rds/charter}} and the DCMI RDF Application Profiles WG\footnote{\url{http://wiki.dublincore.org/index.php/RDF-Application-Profiles}}. 

There are long and controversial discussions in these WGs if or if not OWL should be used RDF validation when assuming closed world semantics.
OWL is an instantiation of a DSCL which is high-level, human-friendly (human-readable and human-understandable), fairly concise, and very expressive.
There are lots of benefits but also a huge amount of drawbacks when using OWL for the purpose to formulate and to validate RDF constraints.

\begin{itemize}
	\item explain why specific OWL 2 constructs could be used for RDF validation 
	\item explain why specific OWL 2 constructs should not be used for RDF validation
\end{itemize}

For RDF, SPARQL is generally seen as the method of choice to validate data according to certain constraints, although it is not ideal for their formulation. 
In contrast, OWL 2 DL constraints are comparatively easy to understand, but lack an implementation to validate RDF data.
Within our developed SPIN\footnote{\url{http://spinrdf.org/}} validation environment, we fully implemented an automatic validation of all OWL 2 DL constructs. 
The implementation can be tested at \url{http://purl.org/net/rdfval-demo} and
the OWL 2 SPIN mapping is maintained at \url{https://github.com/boschthomas/OWL2-SPIN-Mapping}.

\textbf{Constraint Validation with Reasoning}

Constraint validation does not appear to be part of the services provided by
OWL.  This has lead to claims that OWL cannot be used for constraint
validation.  However inference, which is the core service provided by OWL,
and constraint validation are indeed very closely related.

Inference is the process of determining what follows from what has been
stated.  Inference ranges from simple (students are people, John is a
student, therefore John is a person) to the very complex.  Inference can
also recognize impossibilities (students are people, John is a student, John
is not a person, therefore there is a contradiction).  In the presence of
complete information, nothing new can be inferred, so inference only checks
for impossibilities, i.e., constraint violations.  

\begin{itemize}
	\item inferencing as a pre/post validation step
	\item both should be possible: (1) constraint validation with reasoning and (2) constraint validation without reasoning 
\end{itemize}

With regard to typing, W3C is assuming (AFAIK) that all types will be
explicit in the instance data - for the purposes of validation. There is
nothing, however, to prevent an application from running reasoning prior
to validation to add inferred triples to the data being validated. But
the general feeling right now is that validation acts on instance data
without requiring that the validator apply reasoning in order to do so.

Then I wonder what would be the situation if we recommend that reasoning should happen prior to validation. Reasoning will 'fix' the data in some case (R-25 and R-28) but it would make the data more 'redundant' in others (R-224).

Nehmen wir nun an, dass dein Framework welches entsprechende SPARQL Queries generiert diese auf einem SPARQL Endpoint evaluiert der zu der vorliegenden Ontologie bzw. des darin verwendeten OWL 2 Profils das entsprechende Entailment Regime realisiert, wären die zurückgegebenen Resultsets vollständig. Wie das Entailment Regime im Endpoint realisiert ist, also durch Query Rewriting oder durch Vervollständigung der ABox, ist dabei irrelevant.

Wie allerdings bspw. in 
\url{https://www.uni-ulm.de/fileadmin/website_uni_ulm/iui.inst.090/Lehre/WS_2011-2012/SemWebGrundlagen/LectureNotes.pdf}
auf Seite 51 veranschaulicht, ist die Komplexität des Reasoning abhängig von der zugrunde gelegten Sprache und kann daher nur in bestimmten Fällen effizient durchgeführt werden. Wie in unserem letzten Paper beschrieben zielt unter anderem die Definition von DL-Lite gerade darauf ab Reasoning Aufgaben und Query Answering effizient zu ermöglichen und ist Grundlage des OWL 2 QL Profils. Nun ist allgemein bekannt, dass die logische Konsistenz für diese Art von Sprachen effizient geprüft werden kann. 

Allerding wäre wie bspw. in 
\url{http://www.aifb.kit.edu/images/d/d2/2005_925_Haase_Consistent_Evol_1.pdf} beschrieben auch eine sogenannte 'User-defined Consistency' denkbar. Genau an dieser Stelle könnten wir ansetzen.

We answer the following \textbf{research questions}:
\begin{enumerate}
	\item which constraints are expressible by DL?
	\item which constraints are not expressible by DL but by a query language such as Datalog or SPARQL?
	\item for which requirements formulating RDF constraints the expressivity of DL-Lite$_A$ respectively OWL 2 QL is sufficient?
	\item for which requirements additional constraint languages are needed to express related constraints?
	\item which constraint languages are suitable to express these constraints?
	\item what are the effects on complexity to express these constraints with and without OWL 2 QL and OWL 2 DL inferencing?
	\item what are the effects on complexity of constraints expressible by DL?
	\item what are the effects on complexity of constraints not expressible by DL but by a query language?
\end{enumerate}

\textbf{Contributions} of this paper are:
\begin{enumerate}
  \item
	\item
	\item We evaluated to which extend the 5 possible standard constraint languages fulfill each requirement.
\end{enumerate}

\textbf{Ideas}

\begin{itemize}
	\item RDF validation using OWL 2 QL reasoning by SPARQL query expansion
	\item if using OWL 2 DL as constraint language or using constraints equivalent to OWL 2 QL you can use reasoning 
	\item reasoning can also be executed using SPARQL query expansion.
	\item reasoning not executing using reasoner
\end{itemize}

\begin{itemize}
	\item complete with reasoning | OW
	\item complete without reasoning | CW
	\item there is no query rewriting mechanism for OWL 2, just for OWL 2 QL
	\item show that OWL 2 QL and further constraint languages together are complete
\end{itemize}

\section{RDF Validation and Inferencing}

\subsection{OWL 2 QL Reasoning}

An OWL 2 profile (commonly called a fragment or a sublanguage in computational logic) is a trimmed down version of OWL 2 that trades some expressive power for the efficiency of reasoning. This document describes three profiles of OWL 2, each of which achieves efficiency in a different way and is useful in different application scenarios. The profiles are independent of each other, so (prospective) users can skip over the descriptions of profiles that are not of interest to them. The choice of which profile to use in practice will depend on the structure of the ontologies and the reasoning tasks at hand (see Section 10 of the OWL 2 Primer [OWL 2 Primer] for more help in understanding and selecting profiles) \cite{owl2profiles2008}. 

OWL 2 QL is aimed at applications that use very large volumes of instance data, and where query answering is the most important reasoning task. In OWL 2 QL, conjunctive query answering can be implemented using conventional relational database systems. Using a suitable reasoning technique, sound and complete conjunctive query answering can be performed in LOGSPACE with respect to the size of the data (assertions). As in OWL 2 EL, polynomial time algorithms can be used to implement the ontology consistency and class expression subsumption reasoning problems. The expressive power of the profile is necessarily quite limited, although it does include most of the main features of conceptual models such as UML class diagrams and ER diagrams. The QL acronym reflects the fact that query answering in this profile can be implemented by rewriting queries into a standard relational Query Language \cite{owl2profiles2008}. 

\textbf{Logical Underpinning for OWL 2 QL.}
OWL 2 QL is based on the DL-Lite family of description logics. Several variants of DL-Lite have been described in the literature, and DL-Lite$_R$ provides the logical underpinning for OWL 2 QL. DL-Lite$_R$ does not require the unique name assumption (UNA), since making this assumption would have no impact on the semantic consequences of a DL-Lite$_R$ ontology. More expressive variants of DL-Lite, such as DL-Lite$_A$, extend DL-Lite$_R$ with functional properties, and these can also be extended with keys; however, for query answering to remain in LOGSPACE, these extensions require UNA and need to impose certain global restrictions on the interaction between properties used in different types of axiom. Basing OWL 2 QL on DL-Lite$_R$ avoids practical problems involved in the explicit axiomatization of UNA \cite{owl2profiles2008}. 

\subsection{Subsumption}

Subsumption relationships of both classes and properties are part of basic inferencing.

\begin{DL}
:Jedi $\sqsubseteq$ :FeelingForce \\
:JediMaster $\sqsubseteq$ :Jedi \\
\end{DL}

All Jedi masters are Jedis feeling the force.
These sub-class relationships can also be expressed by OWL 2 QL:

\begin{ex}
:Jedi rdfs:subClassOf :FeelingForce . 
:JediMaster rdfs:subClassOf :Jedi . 
\end{ex}

Valid data must contain the 3 class assignments:

\begin{ex}
:Yoda a :JediMaster . 
:Yoda a :Jedi . 
:Yoda a :FeelingForce .
\end{ex}

These class assignments can be either explicitly stated or implicitly inferred when reasoning is performed before actually validating the data.

When only the triple \ms{:Yoda a :JediMaster} is given and inferencing is not executed, then a constraint violation is raised.
After reasoning, however, the triples \ms{:Yoda a :Jedi , :FeelingForce} are inferred resulting in valid data. 

\subsection{Property Axioms}

The property domain constraint

\begin{DL}
$\exists$ :studentOf . $\top$ $\sqsubseteq$ :JediStudent \\
\end{DL}

restricts that individuals having :studentOf relationships must be Jedi students.
This property domain constraint can also be expressed by OWL 2 QL:

\begin{ex}
:studentOf rdfs:domain :JediStudent .
\end{ex}

Without reasoning, the data \ms{:Anakin :studentOf :Obi-Wan} is invalid and causes a constraint violation, as it is not explicitly stated that \ms{:Anakin} is assigned to the class \ms{:Jedi}. 
When inferencing is performed before validating, the class assignment \ms{:Anakin rdf:type :Jedi} is inferred which prevents the constraint violation to be raised.

\subsection{Property Restrictions}

\begin{DL}
$\exists$ :hasLaserSword . :LaserSword
\end{DL}

This existential quantification contains all those individuals that are connected by :hasLaserSword to an individual that is an instance of the class :LaserSword.
In OWL 2 DL, this existential quantification can also be expressed:

\begin{ex}
[ a owl:Restriction ;
  owl:onProperty :hasLaserSword ;
  owl:someValuesFrom :LaserSword ;
  rdfs:subClassOf :Jedi ] .
\end{ex}

When our data contains the triple \ms{:Luke :hasLaserSword :BlueLaserSword} and we perform reasoning, we can infer that \ms{:Luke} is a :Jedi, as he has a laser sword.
As the individual \ms{:Luke} is assigned to the class :Jedi, all constraint associated with this class are also validated, for example that Jedis must have blue laser swords.
Without reasoning, these constraints won't be validated as \ms{:Luke} is not within the class extension of \ms{:Jedi}.

\section{RDF Validation Requirements}

\subsection{Expressible by OWL 2 QL}

\subsection{Not Expressible by OWL 2 QL but by OWL 2 DL}

\subsection{Not Intuitively Expressible by OWL 2 DL}

\begin{itemize}
	\item OWL 2 DL Workarounds
  \item more intuitively expressible by other constraint languages
\end{itemize}

\textbf{Context-Specific Exclusive OR of Properties}

\begin{ex}
# ShEx
# ----
:Jedi { (  
    :attackingBySword xsd:boolean | 
    :attackingByForce xsd:boolean ) }
\end{ex}

\begin{ex}
# OWL 2 DL
# --------
:FeelingForce owl:disjointUnionOf ( :CC1 :CC2 ) . 
:CC1 rdfs:subClassOf [
    a owl:Restriction ;
    owl:onProperty :attackingBySword ;
    owl:allValuesFrom xsd:boolean ] .
:CC2 rdfs:subClassOf [
    a owl:Restriction ;
    owl:onProperty :attackingByForce ;
    owl:allValuesFrom xsd:boolean ] .
\end{ex}

A Jedi is either attacking by sword or attacking by force but not both, as such a fight won't be a fair one.

\begin{DL}
A $\equiv$ $\forall$ :attackingBySword . xsd:boolean \\
B $\equiv$ $\forall$ :attackingByForce . xsd:boolean \\ 
:FeelingForce $\sqsubseteq$ ($\neg$ A $\sqcap$ B) $\sqcup$ (A $\sqcap$ $\neg$ B) \\
\end{DL}

\begin{ex}
:Luke :attackingBySword true .
:DarthSidious 
    :attackingByForce true ;
    :attackingBySword true ;
\end{ex}

Luke is a Jedi, but Darth Sidious is not. 

\subsection{Not Expressible by OWL 2 DL But by Other Constraint Languages}

\section{Evaluation}

We evaluated to which extend the 5 possible standard constraint languages fulfill each requirement to formulate RDF constraints.
Tilde means that this constraint may be fulfilled by that particular constraint language - either by limitations, workarounds, or extensions.
We also evaluated if a specific constraint is fulfilled by OWL 2 QL or if the more expressive OWL 2 DL is needed. 
Inferencing may be performed for constraints marked with an asterisk. 

We divide these constraints into 3 classes:

\begin{itemize}
	\item constraints expressible by OWL 2 QL
	\item constraints not expressible by OWL 2 QL but by OWL 2 DL
	\item constraints only expressible by other DSCLs
\end{itemize}
 
\subsection{constraints expressible by OWL 2 QL}

\tb{ToDo Thomas: insert table}

\subsection{constraints not expressible by OWL 2 QL but by OWL 2 DL}

\tb{ToDo Thomas: insert table}

\subsection{constraints only expressible by other DSCLs}

\tb{ToDo Thomas: insert table}

\section{Computational Complexity of RDF Constraints}

According to our evaluation of requirements to formulate RDF constraints, we identified 3 classes how to validate constraints:

\begin{enumerate}
	\item validation by query answering without reasoning
	\item validation by query answering with OWL 2 QL reasoning
	\item validation by query answering with OWL 2 DL reasoning
\end{enumerate}

The next table gives an overview over the computational complexity for RDF validation when inferencing is performed and when inferencing is not performed. 

\begin{complexity}
validation by query answering without reasoning & PSPACE-Complete \\
validation by query answering with OWL 2 QL reasoning & PTIME \\
validation by query answering with OWL 2 DL reasoning & N2EXPTIME \\
\end{complexity}

\begin{itemize}
	\item Query answering in OWL 2 QL is in LOGSPACE (or rather in AC$^2$ ), so constraint validation by queries without reasoning should be in the same complexity.
  \item (TBox) Reasoning in OWL 2 QL is in PTIME, so rewriting of queries to receive “complete“ results is in this complexity \cite{Artale2009,Calvanese2007}.
  \item The combined complexity is probably still LOGSPACE, but I’m not sure about that.
	\item Perhaps, I better pronounce it. Roughly, the famous paper by Guiterrez (http://dl.acm.org/citation.cfm?id=1567278) says that evaluating SPARQL queries  are of computational complexity PSPACE-Complete. So now, notice that N2EXPTIME (OWL 2 DL reasoning) refers to (a lot) harder class than PSPACE.
\end{itemize}

\tb{ToDO for Andy and Erman: please include references}

\section{Related Work}

\section{Conclusion and Future Work}

\bibliography{../../literature/literature}{}
\bibliographystyle{plain}
\setcounter{tocdepth}{1}
%\listoftodos
\end{document}
